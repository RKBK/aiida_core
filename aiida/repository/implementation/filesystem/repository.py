# -*- coding: utf-8 -*-

import os
import tempfile
import itertools
import uuid as UUID
import errno

from abc import ABCMeta, abstractmethod
from aiida.repository.repository import Repository

class RepositoryFileSystem(Repository):
    """
    """
    __metaclass__ = ABCMeta

    def __init__(self, repo_config):
        """
        :param repo_config: dictionary with configuration details for repository
        """
        self.uuid_file = repo_config['uuid_file']
        self.base_path = repo_config['base_path']


    def _mkdir(self, path):
        """
        Given a directory path, will attempt to create the directory even
        if it contains multiple nested directories that do not exist yet

        :param path: string directory path
        """
        try:
            os.makedirs(path)
        except OSError as error:
            if error.errno == errno.EEXIST and os.path.isdir(path):
                pass
            else:
                raise


    def _uniquify(self, key):
        """
        Given a key for an object, make sure it is unique, by adding a suffix
        of the format '(%d)' to the original key, such that the resulting new key
        corresponds to a filepath that does not yet exist.

        :param key: string with object key
        :return: string with unique object key
        """
        filepath = os.path.join(self.base_path, key)

        count = 1
        unique_path = '%s(%d)' % (filepath, count)
        while os.path.isfile(unique_path):
            count += 1
            unique_path = '%s(%d)' % (filepath, count)

        unique_key = os.path.relpath(unique_path, self.base_path)

        return unique_key


    def _validate_key(self, key):
        """
        Validate a key. In this file system implementation the key actually represents
        a real path, within the repository, where the content of an object will be
        stored in the file system.

        :raise ValueError: raises exception if key is not a normalized path
        :raise ValueError: raises exception if key represenat a path outside the current parent directory
        """
        if key != os.path.normpath(key):
            raise ValueError("Only normalized paths are allowed {}".format(os.path.normpath(key)))
        if key.startswith(os.path.pardir):
            raise ValueError("Cannot go outside parent directory: '{}'".format(key))


    def get_uuid(self):
        """
        Return the UUID identifying the repository.
        Each implementation will decide how to store it: 
        e.g. in a FS it could be a file repo_uuid.txt in the main folder,
        in a object store it could be stored under a key name 'repo_uuid' (making
        sure no object can be stored with the same name) etc.

        :return uuid: the uuid associated with this repository
        :raise ValueError: raises exception if the file that should contain the repo uuid cannot be read
        """
        filepath = os.path.join(self.base_path, self.uuid_file)
        try:
            with open(filepath) as f:
                content = f.read()
        except IOError:
            raise ValueError("Cannot read '{}' and therefore cannot retrieve the UUID associated with this repository".format(filepath))

        return content.strip()


    def put_object(self, key, content, stop_if_existing=False):
        """
        Add the object to the repository with the specified content if 
        it does not exist. Overwrite if exists and stop_if_existing is False.
        Raise an exception if stop_if_existing is True and the object already exists.

        :param key: fully qualified identifier for the object within the repository
        :param content: file or filelike
        :param stop_if_existing:
        """
        self._validate_key(key)

        if stop_if_existing and self.exists(key):
            raise ValueError("Cannot write to '{}' because the object already exists".format(key))

        path = os.path.join(self.base_path, os.path.dirname(key))
        self._mkdir(path)

        try:
            with open(os.path.join(self.base_path, key), 'w') as f:
                f.write(content)
        except IOError as error:
            raise ValueError("Writing object with key '{}' to '{}' failed".format(key, os.path.join(self.base_path, key)))


    def put_new_object(self, content, node_uuid = '', path = ''):
        """
        Add the object to the repository with some autogenerated name.
        Can (optionally) use the information from node_uuid (string) and path (string),
        but it is not needed.
        Must return the key used to store the object.
        It never overwrites existing data. If you want to overwrite an existing object,
        call put_object passing the correct key.

        :return: the key of the newly generated object
        """
        if not node_uuid:
            node_uuid = unicode(UUID.uuid4())
        if not path:
            path = unicode(UUID.uuid4())

        key = os.path.join(node_uuid, path)

        if self.exists(key):
            key = self._uniquify(key)

        self.put_object(key, content, True)

        return key


    def exists(self, key):
        """
        Determine whether the object identified by key exists and is readable

        :return boolean: returns True if the object exists and is readable, False otherwise
        """
        filepath = os.path.join(self.base_path, key)
        try:
            with open(filepath) as f:
                is_readable = True
        except IOError as error:
            is_readable = False

        return is_readable


    def get_object(self, key):
        """
        Return the content of a object identified by key

        :param key: string that uniquely determines location of object within the repository
        :raise ValueError: raises exception if given key can not be resolved to readable object
        """
        filepath = os.path.join(self.base_path, key)
        try:
            with open(filepath) as f:
                content = f.read()
        except IOError as error:
            raise ValueError("Provided key can not be mapped to an existing object")

        return content


    def del_object(self, key):
        """
        Delete the object from the repository

        :param key: string that uniquely determines location of object within the repository
        """
        filepath = os.path.join(self.base_path, key)
        try:
            os.remove(filepath)
        except OSError as error:
            pass